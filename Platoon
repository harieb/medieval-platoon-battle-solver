import itertools as it

def XyZ(a): # Parse platoons
    b = []
    for c in a.split(';'):
        d, e = c.split('#')
        b.append((d, int(e)))
    return b

def ChEck(A,B): # Check advantage
    D = {
        'Militia': ['Spearmen', 'LightCavalry'],
        'Spearmen': ['LightCavalry', 'HeavyCavalry'],
        'LightCavalry': ['FootArcher', 'CavalryArcher'],
        'HeavyCavalry': ['Militia', 'FootArcher', 'LightCavalry'],
        'FootArcher': ['Spearmen', 'HeavyCavalry'],
        'CavalryArcher': ['Militia', 'CavalryArcher']
    }
    if B in D.get(A,[]): return 1
    elif A in D.get(B,[]): return -1
    else: return 0

def FiGhT(p,q): # Battle outcome
    a,b = p; x,y = q
    z = ChEck(a,x)
    if z == 1: return b*2 > y
    elif z == -1: return b > y*2
    else: return b > y

def SoLvE(m,n): # Find solution
    for o in it.permutations(m):
        w = 0
        for i in range(5):
            if FiGhT(o[i],n[i]): w += 1
        if w >= 3: return ';'.join(f"{k}#{v}" for k,v in o)
    return "No winning arrangement"

# Inputs (embedded in code)
M = "Spearmen#10;Militia#30;FootArcher#20;LightCavalry#1000;HeavyCavalry#120"
N = "Militia#10;Spearmen#10;FootArcher#1000;LightCavalry#120;CavalryArcher#100"

# Execute
m_pl = XyZ(M)
n_pl = XyZ(N)
print(SoLvE(m_pl, n_pl))
